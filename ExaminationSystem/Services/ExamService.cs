using AutoMapper;
using AutoMapper.QueryableExtensions;
using ExaminationSystem.DTOs.Exam;
using ExaminationSystem.DTOs.Other;
using ExaminationSystem.DTOs.Question;
using ExaminationSystem.Models;
using ExaminationSystem.Models.Enums;
using ExaminationSystem.Repositories;
using ExaminationSystem.ViewModels.Response;
using Microsoft.EntityFrameworkCore;
using PredicateExtensions;
using System.Linq.Expressions;

namespace ExaminationSystem.Services
{
    public class ExamService
    {
        private readonly ExamRepository _examRepository;
        private readonly CourseRepository _courseRepository;
        private readonly StudentRepository _studentRepository;
        private readonly QuestionRepository _questionRepository;
        private readonly ExamQuestionRepository _examQuestionRepository;
        private readonly StudentExamRepository _studentExamRepository;
        private readonly StudentAnswerRepository _studentAnswerRepository;
        private readonly IMapper _mapper;

        // Constructor – initialize repositories and mapper
        public ExamService(IMapper mapper)
        {
            _examRepository = new ExamRepository();
            _courseRepository = new CourseRepository();
            _studentRepository = new StudentRepository();
            _studentExamRepository = new StudentExamRepository();
            _studentAnswerRepository = new StudentAnswerRepository();
            _examQuestionRepository = new ExamQuestionRepository();
            _questionRepository = new QuestionRepository();
            _mapper = mapper;
        }

        // Get all exams
        public async Task<ResponseViewModel<IEnumerable<GetAllExamsDTO>>> GetAll()
        {
            var exams = _examRepository.GetAll();
            var result = await exams.ProjectTo<GetAllExamsDTO>(_mapper.ConfigurationProvider).ToListAsync();
            return (result != null) ? new SuccessResponseViewModel<IEnumerable<GetAllExamsDTO>>(result) :
                new FailResponseViewModel<IEnumerable<GetAllExamsDTO>>("No Exam Exist", ErrorCode.ExamNotFound);
        }

        // Get exam by ID
        public async Task<ResponseViewModel<GetExamByIdDTO>> GetByID(int id)
        {
            if (!_examRepository.IsExists(id))
                new FailResponseViewModel<IEnumerable<GetAllExamsDTO>>("ExamId Not Exists", ErrorCode.InvalidExamId);

            var exam = _examRepository.GetByID(id);
            var result = await exam.ProjectTo<GetExamByIdDTO>(_mapper.ConfigurationProvider).FirstOrDefaultAsync();

            return (result != null) ? new SuccessResponseViewModel<GetExamByIdDTO>(result) :
                new FailResponseViewModel<GetExamByIdDTO>("No Exam Exist", ErrorCode.ExamNotFound);
        }

        // Filter exams by ID, title, or type
        public async Task<ResponseViewModel<IEnumerable<GetAllExamsDTO>>> Get(int? id, string? title, ExamType? type)
        {
            var predicate = ExamPredicateBuilder(id, title, type);
            var exams = _examRepository.Get(predicate);
            var result = await exams.ProjectTo<GetAllExamsDTO>(_mapper.ConfigurationProvider).ToListAsync();
            return (result != null) ? new SuccessResponseViewModel<IEnumerable<GetAllExamsDTO>>(result) :
                new FailResponseViewModel<IEnumerable<GetAllExamsDTO>>("No Exam Exist", ErrorCode.ExamNotFound);
        }

        // Create new exam (with optional auto-generated questions)
        public async Task<ResponseViewModel<bool>> Create(CreateExamDTO dto)
        {
            if (!_courseRepository.IsExists(dto.CourseId))
                return new FailResponseViewModel<bool>("ExamId Not Exist", ErrorCode.InvalidExamId);

            var exam = _mapper.Map<Exam>(dto);
            if (exam == null)
                return new FailResponseViewModel<bool>("Invalid Data", ErrorCode.ExamDateInvalid);

            await _examRepository.AddAsync(exam);

            if (dto.IsAutoGenerated)
            {
                dto.examQuestionDistributionDTO.ExamId = exam.ID;
                await AutoGenerateQuestions(dto.examQuestionDistributionDTO);
            }

            return new SuccessResponseViewModel<bool>(true);
        }

        // Update existing exam
        public async Task<ResponseViewModel<bool>> Update(int id, UpdateExamDTO dto)
        {
            if (!_examRepository.IsExists(id))
                return new FailResponseViewModel<bool>("ExamId Not Exist", ErrorCode.InvalidExamId);

            var existingExam = await _examRepository.GetByIDWithTracking(id);

            // Keep existing values if defaults are passed
            dto = new UpdateExamDTO
            {
                Title = dto.Title == "string" ? existingExam.Title : dto.Title,
                Type = dto.Type == default ? existingExam.Type : dto.Type,
                CourseId = dto.CourseId == 0 ? existingExam.CourseId : dto.CourseId,
                NumberOfQuestions = dto.NumberOfQuestions == 0 ? existingExam.NumberOfQuestions : dto.NumberOfQuestions
            };

            var exam = _mapper.Map<Exam>(dto);
            await _examRepository.UpdateAsync(exam);

            return new SuccessResponseViewModel<bool>(true);
        }

        // Soft delete exam
        public async Task<ResponseViewModel<bool>> SoftDelete(int examId)
        {
            if (!_examRepository.IsExists(examId))
                return new FailResponseViewModel<bool>("ExamId Not Exist", ErrorCode.InvalidExamId);

            await _examRepository.SoftDeleteAsync(examId);
            return new SuccessResponseViewModel<bool>(true);
        }

        // Get all questions for an exam
        public ResponseViewModel<IEnumerable<GetAllQuestionsDTO>> GetExamQuestions(int examId)
        {
            if (!_examRepository.IsExists(examId))
                return new FailResponseViewModel<IEnumerable<GetAllQuestionsDTO>>("ExamId Not Exist", ErrorCode.InvalidExamId);

            var questions = _examQuestionRepository.GetQuestionsByExam(examId);
            var result = _mapper.Map<List<GetAllQuestionsDTO>>(questions);

            return new SuccessResponseViewModel<IEnumerable<GetAllQuestionsDTO>>(result);
        }

        // Assign a question to an exam
        public async Task<ResponseViewModel<bool>> AssignQuestion(ExamQuestionDTO examQuestionDTO)
        {
            if (!_examRepository.IsExists(examQuestionDTO.ExamId))
                return new FailResponseViewModel<bool>("ExamId Not Exist", ErrorCode.InvalidExamId);

            if (!_examRepository.IsExists(examQuestionDTO.QuestionId))
                return new FailResponseViewModel<bool>("QuestionId Not Exist", ErrorCode.InvalidQuestionId);

            if (!_examQuestionRepository.IsAssigned(examQuestionDTO.ExamId, examQuestionDTO.QuestionId))
                return new FailResponseViewModel<bool>("Question aready Assigned to Eaxm ", ErrorCode.QuestionAreadyExists);

            await _examQuestionRepository.Add(_mapper.Map<ExamQuestion>(examQuestionDTO));
            return new SuccessResponseViewModel<bool>(true);
        }

        // Evaluate all students for an exam
        public async Task<ResponseViewModel<bool>> EvaluateAllExams(int examId)
        {
            if (!_examRepository.IsExists(examId))
                return new FailResponseViewModel<bool>("ExamId Not Exist", ErrorCode.InvalidExamId);

            var studentExams = _studentExamRepository.Get(se => se.ExamId == examId).AsTracking().ToList();

            if (studentExams == null)
                return new FailResponseViewModel<bool>("No Students Assigned to this Exam", ErrorCode.StudentNotAssignedToExam);

            // Evaluate each student
            foreach (var st in studentExams)
            {
                await EvaluateExamforStudent(examId, st.StudentId);
            }

            return new SuccessResponseViewModel<bool>(true);
        }

        // Auto-generate questions for an exam based on distribution
        private async Task<ResponseViewModel<bool>> AutoGenerateQuestions(ExamQuestionDistributionDTO dto)
        {
            if (!_examRepository.IsExists(dto.ExamId))
                return new FailResponseViewModel<bool>("Exam not found", ErrorCode.ExamNotFound);

            if (dto.TotalQuestions <= 0)
                return new FailResponseViewModel<bool>("Invalid total questions", ErrorCode.TolalPrcentageInvalid);

            if (dto.SimplePercentage + dto.MediumPercentage + dto.HardPercentage != 100)
                return new FailResponseViewModel<bool>("Percentages must equal 100", ErrorCode.TotalPrcentageNot100);

            await _examQuestionRepository.RemoveAllQuestionsFromExam(dto.ExamId);

            // Calculate number of questions per level
            int simpleCount = dto.TotalQuestions * dto.SimplePercentage / 100;
            int mediumCount = dto.TotalQuestions * dto.MediumPercentage / 100;
            int hardCount = dto.TotalQuestions - (simpleCount + mediumCount);

            var simple = await GetRandomQuestions(QuestionLevel.Simple, simpleCount);
            var medium = await GetRandomQuestions(QuestionLevel.Medium, mediumCount);
            var hard = await GetRandomQuestions(QuestionLevel.Hard, hardCount);

            if (simple.Count < simpleCount || medium.Count < mediumCount || hard.Count < hardCount)
                return new FailResponseViewModel<bool>("Not enough questions to generate exam", ErrorCode.TotalPrcentageNot100);

            foreach (var question in simple.Concat(medium).Concat(hard))
            {
                await _examQuestionRepository.Add(new ExamQuestion
                {
                    ExamId = dto.ExamId,
                    QuestionId = question.ID
                });
            }

            return new SuccessResponseViewModel<bool>(true);
        }

        // Fetch random questions of a given level
        private async Task<List<Question>> GetRandomQuestions(QuestionLevel level, int count)
        {
            if (count == 0)
                return new List<Question>();

            return await _questionRepository
                .Get(q => q.Level == level && !q.IsDeleted)
                .OrderBy(q => Guid.NewGuid())
                .Take(count)
                .ToListAsync();
        }

        // Evaluate a single student's exam
        private async Task<ResponseViewModel<bool>> EvaluateExamforStudent(int studentId, int examId)
        {
            if (!_examRepository.IsExists(examId))
                return new FailResponseViewModel<bool>("ExamId Not Exist", ErrorCode.InvalidExamId);
            if (!_studentRepository.IsExists(studentId))
                return new FailResponseViewModel<bool>("StudentId Not Exist", ErrorCode.InvalidStudentId);
            if (!_studentExamRepository.IsAssigned(studentId, examId))
                return new FailResponseViewModel<bool>("Student Not Assigned to this Exam", ErrorCode.StudentNotAssignedToExam);
            if (!_studentExamRepository.IsSubmitted(studentId, examId))
                return new FailResponseViewModel<bool>("Exam Not Submitted Yet", ErrorCode.StudentNotSubmittedExam);

            int correct = _studentAnswerRepository.CountCorrectAnswers(studentId, examId);
            int total = _studentAnswerRepository.GetAnswersByStudentExam(studentId, examId).Count();

            var studentExam = await _studentExamRepository.GetWithTracking(studentId, examId);
            studentExam.Score = (decimal)correct / total * 100;
            await _studentExamRepository.Update(studentExam);

            return new SuccessResponseViewModel<bool>(true);
        }

        // Build dynamic predicate for filtering exams
        private Expression<Func<Exam, bool>> ExamPredicateBuilder(int? id, string? title, ExamType? type)
        {
            var predicate = PredicateExtensions.PredicateExtensions.Begin<Exam>(true);

            if (id.HasValue)
            {
                if (_examRepository.IsExists(id.Value) == false)
                    predicate = predicate.And(e => e.ID == id.Value);
            }

            if (!string.IsNullOrEmpty(title))
            {
                predicate = predicate.And(e => e.Title.Contains(title));
            }

            if (type.HasValue)
            {
                predicate = predicate.And(e => e.Type == type.Value);
            }

            return predicate;
        }
    }
}
