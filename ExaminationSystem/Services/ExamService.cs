using AutoMapper;
using AutoMapper.QueryableExtensions;
using ExaminationSystem.DTOs.Exam;
using ExaminationSystem.DTOs.Other;
using ExaminationSystem.DTOs.Question;
using ExaminationSystem.Models;
using ExaminationSystem.Models.Enums;
using ExaminationSystem.Repositories;
using ExaminationSystem.ViewModels.Response;
using Microsoft.EntityFrameworkCore;
using PredicateExtensions;
using System.Linq.Expressions;

namespace ExaminationSystem.Services
{
    public class ExamService
    {
        #region Repositories & Mapper
        private readonly ExamRepository _examRepository;
        private readonly CourseRepository _courseRepository;
        private readonly StudentRepository _studentRepository;
        private readonly QuestionRepository _questionRepository;
        private readonly ExamQuestionRepository _examQuestionRepository;
        private readonly StudentExamRepository _studentExamRepository;
        private readonly StudentAnswerRepository _studentAnswerRepository;
        private readonly IMapper _mapper;
        #endregion

        #region Constructor
        public ExamService(IMapper mapper)
        {
            _examRepository = new ExamRepository();
            _courseRepository = new CourseRepository();
            _studentRepository = new StudentRepository();
            _studentExamRepository = new StudentExamRepository();
            _studentAnswerRepository = new StudentAnswerRepository();
            _examQuestionRepository = new ExamQuestionRepository();
            _questionRepository = new QuestionRepository();
            _mapper = mapper;
        }
        #endregion

        #region Exam Retrieval

        public async Task<ResponseViewModel<IEnumerable<GetAllExamsDTO>>> GetAll()
        {
            var exams = _examRepository.GetAll();
            var result = await exams.ProjectTo<GetAllExamsDTO>(_mapper.ConfigurationProvider).ToListAsync();
            return (result != null && result.Any())
                ? new SuccessResponseViewModel<IEnumerable<GetAllExamsDTO>>(result)
                : new FailResponseViewModel<IEnumerable<GetAllExamsDTO>>("No exams found", ErrorCode.ExamNotFound);
        }

        public async Task<ResponseViewModel<GetExamByIdDTO>> GetByID(int id)
        {
            if (!_examRepository.IsExists(id))
                return new FailResponseViewModel<GetExamByIdDTO>("Exam ID does not exist", ErrorCode.InvalidExamId);

            var exam = _examRepository.GetByID(id);
            var result = await exam.ProjectTo<GetExamByIdDTO>(_mapper.ConfigurationProvider).FirstOrDefaultAsync();

            return (result != null)
                ? new SuccessResponseViewModel<GetExamByIdDTO>(result)
                : new FailResponseViewModel<GetExamByIdDTO>("Exam not found", ErrorCode.ExamNotFound);
        }

        public async Task<ResponseViewModel<IEnumerable<GetAllExamsDTO>>> Get(int? id, string? title, ExamType? type)
        {
            var predicate = ExamPredicateBuilder(id, title, type);
            var exams = _examRepository.Get(predicate);
            var result = await exams.ProjectTo<GetAllExamsDTO>(_mapper.ConfigurationProvider).ToListAsync();

            return (result != null && result.Any())
                ? new SuccessResponseViewModel<IEnumerable<GetAllExamsDTO>>(result)
                : new FailResponseViewModel<IEnumerable<GetAllExamsDTO>>("No exams matched the filter", ErrorCode.ExamNotFound);
        }

        #endregion

        #region Exam Management

        public async Task<ResponseViewModel<bool>> Create(CreateExamDTO dto)
        {
            if (!_courseRepository.IsExists(dto.CourseId))
                return new FailResponseViewModel<bool>("Course ID does not exist", ErrorCode.InvalidCourseId);

            var exam = _mapper.Map<Exam>(dto);
            if (exam == null)
                return new FailResponseViewModel<bool>("Invalid exam data", ErrorCode.InvalidExamData);

            await _examRepository.AddAsync(exam);

            if (dto.IsAutoGenerated)
            {
                dto.examQuestionDistributionDTO.ExamId = exam.ID;
                await AutoGenerateQuestions(dto.examQuestionDistributionDTO);
            }

            return new SuccessResponseViewModel<bool>(true);
        }

        public async Task<ResponseViewModel<bool>> Update(int id, UpdateExamDTO dto)
        {
            if (!_examRepository.IsExists(id))
                return new FailResponseViewModel<bool>("Exam ID does not exist", ErrorCode.InvalidExamId);

            var existingExam = await _examRepository.GetByIDWithTracking(id);

            dto = new UpdateExamDTO
            {
                Title = dto.Title == "string" ? existingExam.Title : dto.Title,
                Type = dto.Type == default ? existingExam.Type : dto.Type,
                CourseId = dto.CourseId == 0 ? existingExam.CourseId : dto.CourseId,
                NumberOfQuestions = dto.NumberOfQuestions == 0 ? existingExam.NumberOfQuestions : dto.NumberOfQuestions
            };

            var exam = _mapper.Map<Exam>(dto);
            await _examRepository.UpdateAsync(exam);

            return new SuccessResponseViewModel<bool>(true);
        }

        public async Task<ResponseViewModel<bool>> SoftDelete(int examId)
        {
            if (!_examRepository.IsExists(examId))
                return new FailResponseViewModel<bool>("Exam ID does not exist", ErrorCode.InvalidExamId);

            await _examRepository.SoftDeleteAsync(examId);
            return new SuccessResponseViewModel<bool>(true);
        }

        #endregion

        #region Exam Questions

        public ResponseViewModel<IEnumerable<GetAllQuestionsDTO>> GetExamQuestions(int examId)
        {
            if (!_examRepository.IsExists(examId))
                return new FailResponseViewModel<IEnumerable<GetAllQuestionsDTO>>("Exam ID does not exist", ErrorCode.InvalidExamId);

            var questions = _examQuestionRepository.GetQuestionsByExam(examId);
            var result = _mapper.Map<List<GetAllQuestionsDTO>>(questions);

            return new SuccessResponseViewModel<IEnumerable<GetAllQuestionsDTO>>(result);
        }

        public async Task<ResponseViewModel<bool>> AssignQuestion(ExamQuestionDTO examQuestionDTO)
        {
            if (!_examRepository.IsExists(examQuestionDTO.ExamId))
                return new FailResponseViewModel<bool>("Exam ID does not exist", ErrorCode.InvalidExamId);

            if (!_questionRepository.IsExists(examQuestionDTO.QuestionId))
                return new FailResponseViewModel<bool>("Question ID does not exist", ErrorCode.InvalidQuestionId);

            if (_examQuestionRepository.IsAssigned(examQuestionDTO.ExamId, examQuestionDTO.QuestionId))
                return new FailResponseViewModel<bool>("Question already assigned to this exam", ErrorCode.QuestionAlreadyAssigned);

            await _examQuestionRepository.Add(_mapper.Map<ExamQuestion>(examQuestionDTO));
            return new SuccessResponseViewModel<bool>(true);
        }

        #endregion

        #region Exam Evaluation

        public async Task<ResponseViewModel<bool>> EvaluateAllExams(int examId)
        {
            if (!_examRepository.IsExists(examId))
                return new FailResponseViewModel<bool>("Exam ID does not exist", ErrorCode.InvalidExamId);

            var studentExams = _studentExamRepository.Get(se => se.ExamId == examId).AsTracking().ToList();

            if (!studentExams.Any())
                return new FailResponseViewModel<bool>("No students assigned to this exam", ErrorCode.StudentNotAssignedToExam);

            foreach (var st in studentExams)
            {
                await EvaluateExamforStudent(examId, st.StudentId);
            }

            return new SuccessResponseViewModel<bool>(true);
        }

        private async Task<ResponseViewModel<bool>> EvaluateExamforStudent(int studentId, int examId)
        {
            if (!_examRepository.IsExists(examId))
                return new FailResponseViewModel<bool>("Exam ID does not exist", ErrorCode.InvalidExamId);

            if (!_studentRepository.IsExists(studentId))
                return new FailResponseViewModel<bool>("Student ID does not exist", ErrorCode.InvalidStudentId);

            if (!_studentExamRepository.IsAssigned(studentId, examId))
                return new FailResponseViewModel<bool>("Student not assigned to this exam", ErrorCode.StudentNotAssignedToExam);

            if (!_studentExamRepository.IsSubmitted(studentId, examId))
                return new FailResponseViewModel<bool>("Exam not submitted yet", ErrorCode.StudentNotSubmittedExam);

            int correct = _studentAnswerRepository.CountCorrectAnswers(studentId, examId);
            int total = _studentAnswerRepository.GetAnswersByStudentExam(studentId, examId).Count();

            var studentExam = await _studentExamRepository.GetWithTracking(studentId, examId);
            studentExam.Score = (decimal)correct / total * 100;
            await _studentExamRepository.Update(studentExam);

            return new SuccessResponseViewModel<bool>(true);
        }

        #endregion

        #region Auto Generation of Questions

        private async Task<ResponseViewModel<bool>> AutoGenerateQuestions(ExamQuestionDistributionDTO dto)
        {
            if (!_examRepository.IsExists(dto.ExamId))
                return new FailResponseViewModel<bool>("Exam not found", ErrorCode.ExamNotFound);

            if (dto.TotalQuestions <= 0)
                return new FailResponseViewModel<bool>("Invalid total questions", ErrorCode.InvalidTotalQuestions);

            if (dto.SimplePercentage + dto.MediumPercentage + dto.HardPercentage != 100)
                return new FailResponseViewModel<bool>("Percentages must sum to 100", ErrorCode.TotalPercentageNot100);

            await _examQuestionRepository.RemoveAllQuestionsFromExam(dto.ExamId);

            int simpleCount = dto.TotalQuestions * dto.SimplePercentage / 100;
            int mediumCount = dto.TotalQuestions * dto.MediumPercentage / 100;
            int hardCount = dto.TotalQuestions - (simpleCount + mediumCount);

            var simple = await GetRandomQuestions(QuestionLevel.Simple, simpleCount);
            var medium = await GetRandomQuestions(QuestionLevel.Medium, mediumCount);
            var hard = await GetRandomQuestions(QuestionLevel.Hard, hardCount);

            if (simple.Count < simpleCount || medium.Count < mediumCount || hard.Count < hardCount)
                return new FailResponseViewModel<bool>("Not enough questions to generate exam", ErrorCode.NotEnoughQuestions);

            foreach (var question in simple.Concat(medium).Concat(hard))
            {
                await _examQuestionRepository.Add(new ExamQuestion
                {
                    ExamId = dto.ExamId,
                    QuestionId = question.ID
                });
            }

            return new SuccessResponseViewModel<bool>(true);
        }

        private async Task<List<Question>> GetRandomQuestions(QuestionLevel level, int count)
        {
            if (count == 0)
                return new List<Question>();

            return await _questionRepository
                .Get(q => q.Level == level && !q.IsDeleted)
                .OrderBy(q => Guid.NewGuid())
                .Take(count)
                .ToListAsync();
        }

        #endregion

        #region Predicate Builder

        private Expression<Func<Exam, bool>> ExamPredicateBuilder(int? id, string? title, ExamType? type)
        {
            var predicate = PredicateExtensions.PredicateExtensions.Begin<Exam>(true);

            if (id.HasValue)
                predicate = predicate.And(e => e.ID == id.Value);

            if (!string.IsNullOrEmpty(title))
                predicate = predicate.And(e => e.Title.Contains(title));

            if (type.HasValue)
                predicate = predicate.And(e => e.Type == type.Value);

            return predicate;
        }

        #endregion
    }
}
